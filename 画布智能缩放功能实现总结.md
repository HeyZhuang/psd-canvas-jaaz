# 画布智能缩放功能实现总结

## 📋 功能概述

成功实现了画布智能缩放功能，支持两个阶段：
1. **第一步（已完成）**：缩放整个画布，返回PNG格式
2. **第二步（已完成）**：支持返回PSD格式（分层）

## 🎯 核心功能

### 1. 缩放模式选择
- **缩放单个PSD文件**：原有功能，缩放已上传的PSD文件
- **缩放整个画布**：新功能，缩放画布上的所有图片元素

### 2. 输出格式选择（画布模式专属）
- **PNG格式**：将所有图层合成为一张图片
- **PSD格式**：保留图层结构（实验性功能）

## 📁 文件结构

### 前端文件

#### 1. `/home/ubuntu/jaaz/react/src/utils/canvasToPSD.ts`（新建）
**功能**：画布数据收集工具

**核心函数**：
- `collectCanvasImageData()` - 收集画布所有图片元素
- `calculateCanvasBounds()` - 计算画布边界
- `validateCanvasData()` - 验证画布数据

**数据结构**：
```typescript
interface CanvasLayer {
  id: number
  name: string
  x: number
  y: number
  width: number
  height: number
  opacity: number
  fileId: string
  dataURL: string
  zIndex: number | string
}

interface CanvasData {
  width: number
  height: number
  layers: CanvasLayer[]
}
```

#### 2. `/home/ubuntu/jaaz/react/src/components/canvas/PSDResizeDialog.tsx`（修改）
**新增状态**：
- `resizeMode`: 'psd' | 'canvas' - 缩放模式
- `outputFormat`: 'png' | 'psd' - 输出格式

**新增函数**：
- `handleCanvasResize()` - 处理画布缩放
  - 收集画布数据
  - 发送到后端API
  - 自动展示结果到画布

**UI改进**：
- 添加缩放模式选择器（按钮组）
- 添加输出格式选择器（PNG/PSD）
- 条件显示PSD信息或画布信息
- 动态按钮文本

### 后端文件

#### 1. `/home/ubuntu/jaaz/server/utils/canvas_to_psd.py`（新建）
**功能**：画布到PSD转换工具

**核心函数**：
- `decode_base64_image()` - 解码Base64图片
- `save_canvas_layers_separate()` - 将图层保存为独立PNG文件
- `save_canvas_layers_as_psd()` - 合成所有图层为单张图片
- `create_layered_psd_from_resized()` - 从调整后的图层创建PSD

**技术细节**：
- 处理Base64编码的图片数据
- 支持图层透明度
- 自动调整图层大小
- 按zIndex排序保持图层顺序

#### 2. `/home/ubuntu/jaaz/server/routers/canvas_resize_router.py`（新建）
**功能**：画布智能缩放API

**端点**：
- `POST /api/canvas/resize` - 画布智能缩放
  - 参数：canvas_data, target_width, target_height, api_key, output_format
  - 返回：缩放后的图片URL和元数据

**工作流程**：
```
1. 解析画布数据
2. 根据output_format选择处理方式
   - PNG: 合成为单张图片
   - PSD: 保存为独立图层文件
3. 构造图层信息
4. 生成检测框图像
5. 调用Gemini API生成缩放方案
6. 应用缩放方案
   - PNG: 简单缩放合成图
   - PSD: 按新位置重建各图层
7. 保存结果和元数据
8. 返回结果URL
```

**错误处理**：
- JSON解析错误处理
- 超时控制（180秒）
- 临时文件自动清理

#### 3. `/home/ubuntu/jaaz/server/main.py`（修改）
**变更**：
- 导入 `canvas_resize_router`
- 注册路由：`app.include_router(canvas_resize_router.router)`

## 🔄 数据流程

### PNG模式流程
```
前端画布 
  → collectCanvasImageData() 收集数据
  → POST /api/canvas/resize (output_format=png)
  → 后端合成图层
  → Gemini API 分析
  → 简单缩放合成图
  → 返回PNG URL
  → 前端展示到画布
```

### PSD模式流程
```
前端画布
  → collectCanvasImageData() 收集数据
  → POST /api/canvas/resize (output_format=psd)
  → 后端保存独立图层
  → Gemini API 分析
  → 按新位置重建各图层
  → 返回PNG URL（由于psd-tools限制）
  → 前端展示到画布
```

## 🎨 UI改进

### 缩放模式选择
```tsx
<div className="flex gap-2">
  <Button variant={resizeMode === 'psd' ? 'default' : 'outline'}>
    缩放单个PSD文件
  </Button>
  <Button variant={resizeMode === 'canvas' ? 'default' : 'outline'}>
    缩放整个画布
  </Button>
</div>
```

### 输出格式选择（仅画布模式）
```tsx
<div className="flex gap-2">
  <Button variant={outputFormat === 'png' ? 'default' : 'outline'}>
    PNG（图片）
  </Button>
  <Button variant={outputFormat === 'psd' ? 'default' : 'outline'}>
    PSD（分层）
  </Button>
</div>
```

### 智能提示
- PNG模式：显示"PNG模式会将所有图层合成为一张图片"
- PSD模式：显示"PSD模式会保留图层结构（实验性功能）"

## 🔧 技术难点与解决方案

### 1. PSD文件写入限制
**问题**：`psd-tools` 库的写入功能有限，无法直接创建多层PSD

**解决方案**：
- PNG模式：直接合成为单张PNG
- PSD模式：创建独立图层文件，使用Pillow按新位置合成，最终输出PNG
- 保留元数据JSON记录图层信息

### 2. Base64图片处理
**问题**：画布图片以Base64 DataURL形式存储

**解决方案**：
- 创建`decode_base64_image()`函数
- 移除DataURL前缀
- 解码Base64数据
- 转换为PIL Image对象
- 确保RGBA模式

### 3. 图层顺序保持
**问题**：需要保持原画布的图层叠加顺序

**解决方案**：
- 收集时记录zIndex
- 排序：`sorted(layers, key=lambda x: x.get('zIndex', x['id']))`
- 按顺序处理和合成

### 4. 画布边界计算
**问题**：画布元素可能位于任意位置

**解决方案**：
- 计算所有元素的最小/最大坐标
- 确定实际画布尺寸
- 调整图层位置（相对于边界）

## 📊 API接口

### POST /api/canvas/resize

**请求参数**（FormData）：
```typescript
{
  canvas_data: string        // JSON格式的画布数据
  target_width: number       // 目标宽度
  target_height: number      // 目标高度
  output_format: 'png'|'psd' // 输出格式
  api_key?: string          // Gemini API密钥（可选）
}
```

**响应**：
```typescript
{
  success: true,
  file_id: string,
  original_size: { width: number, height: number },
  target_size: { width: number, height: number },
  layers_count: number,
  output_url: string,
  metadata_url: string,
  new_positions: Array<LayerPosition>,
  output_format: 'png'|'psd'
}
```

## 🧪 测试要点

### 功能测试
1. ✅ 画布数据收集正确性
2. ✅ PNG模式缩放
3. ✅ PSD模式缩放
4. ✅ 自动展示到画布
5. ✅ 图层顺序保持
6. ✅ 透明度处理

### 边界测试
1. ⚠️ 空画布处理
2. ⚠️ 单图层画布
3. ⚠️ 大量图层（性能）
4. ⚠️ 超大尺寸图片
5. ⚠️ 网络超时处理

### 错误处理
1. ✅ 画布无图片元素
2. ✅ API调用失败
3. ✅ 超时控制（180秒）
4. ✅ 临时文件清理

## 🚀 使用方法

### 1. 准备画布
- 在Excalidraw画布上添加多个图片元素
- 可以是上传的图片或PSD图层

### 2. 打开智能缩放对话框
- 点击画布工具栏的"智能缩放"按钮

### 3. 选择模式
- **缩放单个PSD**：适用于已上传的PSD文件
- **缩放整个画布**：适用于画布上的所有图片

### 4. 选择输出格式（画布模式）
- **PNG**：快速，适合最终效果预览
- **PSD**：保留图层（实验性）

### 5. 设置目标尺寸
- 输入目标宽度和高度
- 建议范围：100-4000像素

### 6. 配置API密钥（可选）
- 可以直接输入Gemini API密钥
- 或使用环境变量中的密钥

### 7. 开始缩放
- 点击"缩放整个画布"或"开始智能缩放"
- 等待1-2分钟（Gemini API处理时间）
- 缩放完成后自动展示到画布

## 📝 注意事项

### 1. PSD格式限制
由于`psd-tools`库的写入限制，当前PSD模式实际返回的是高质量PNG文件，但会保留图层元数据在JSON中。未来可考虑使用其他PSD库（如`psd-tools3`或`pypsd`）实现真正的多层PSD输出。

### 2. 性能考虑
- 图层数量越多，处理时间越长
- 建议单次缩放不超过20个图层
- 大图片会增加Base64编码/解码时间

### 3. Gemini API配额
- 需要有效的Gemini API密钥
- 注意API配额限制
- 处理失败会返回详细错误信息

### 4. 浏览器内存
- Base64编码会占用较多内存
- 建议在现代浏览器中使用
- 超大图片可能导致浏览器卡顿

## 🔮 未来改进

### 短期（已实现）
- ✅ 支持缩放整个画布
- ✅ 支持PNG输出
- ✅ 支持PSD输出（合成版）
- ✅ 自动展示到画布

### 中期（待实现）
- ⏳ 真正的多层PSD文件输出
- ⏳ 批量处理多个画布
- ⏳ 缩放历史记录
- ⏳ 预设尺寸模板

### 长期（规划中）
- 💡 AI图层分组建议
- 💡 智能图层命名
- 💡 缩放预览功能
- 💡 撤销/重做支持

## 📚 相关文档

- `PSD_RESIZE_AUTO_CANVAS.md` - 自动展示功能技术文档
- `PSD智能缩放自动展示功能.md` - 用户指南
- `快速修复智能缩放.md` - 问题排查指南
- `如何解决配额问题.md` - Gemini API配额解决方案

## 👨‍💻 开发团队

- AI Assistant - 核心功能实现
- 用户 - 需求提出与测试

## 📅 版本历史

- **v2.0** (2025-10-28) - 添加PSD格式支持
- **v1.0** (2025-10-28) - 实现画布缩放PNG功能
- **v0.5** (2025-10-28) - 添加画布数据收集工具

---

**注意**：本文档记录了画布智能缩放功能的完整实现过程，包括技术细节、数据流程和使用方法。如有问题，请参考相关文档或联系开发团队。




